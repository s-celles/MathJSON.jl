var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Expression-Types","page":"API Reference","title":"Expression Types","text":"","category":"section"},{"location":"api/#Parsing","page":"API Reference","title":"Parsing","text":"","category":"section"},{"location":"api/#Generation","page":"API Reference","title":"Generation","text":"","category":"section"},{"location":"api/#Validation","page":"API Reference","title":"Validation","text":"","category":"section"},{"location":"api/#Metadata","page":"API Reference","title":"Metadata","text":"","category":"section"},{"location":"api/#Operators","page":"API Reference","title":"Operators","text":"","category":"section"},{"location":"api/#Symbolics.jl-Integration","page":"API Reference","title":"Symbolics.jl Integration","text":"","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#MathJSON.MathJSONFormat","page":"API Reference","title":"MathJSON.MathJSONFormat","text":"MathJSONFormat\n\nSingleton type used for dispatch in parse(MathJSONFormat, str) and generate(MathJSONFormat, expr) functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.AbstractMathJSONExpr","page":"API Reference","title":"MathJSON.AbstractMathJSONExpr","text":"AbstractMathJSONExpr\n\nAbstract base type for all MathJSON expression types.\n\nAll concrete expression types (NumberExpr, SymbolExpr, StringExpr, FunctionExpr) are subtypes of this abstract type, enabling dispatch-based polymorphism.\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.ExpressionType","page":"API Reference","title":"MathJSON.ExpressionType","text":"ExpressionType\n\nModule containing the expression type enum. Use scoped access to avoid namespace pollution.\n\nExample\n\nexpr_type = ExpressionType.NUMBER\nexpr_type isa ExpressionType.T  # true\n\n\n\n\n\n","category":"module"},{"location":"api/#MathJSON.NumberExpr","page":"API Reference","title":"MathJSON.NumberExpr","text":"NumberExpr <: AbstractMathJSONExpr\n\nRepresents a numeric value in MathJSON format.\n\nFields\n\nvalue::MathJSONNumber: The numeric value (Int64, Float64, BigFloat, or Rational)\nraw::Union{Nothing, String}: Original string representation for extended precision\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nNumberExpr(value)                        # Simple numeric value\nNumberExpr(value, raw)                   # With raw string for precision\nNumberExpr(value, raw, metadata)         # Full constructor\nNumberExpr(value; metadata=nothing)      # With keyword metadata\n\nExamples\n\nn1 = NumberExpr(42)\nn2 = NumberExpr(3.14, \"3.14159265358979323846\")\nn3 = NumberExpr(1//3)\nn4 = NumberExpr(3.14; metadata=Dict(\"wikidata\" => \"Q167\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.SymbolExpr","page":"API Reference","title":"MathJSON.SymbolExpr","text":"SymbolExpr <: AbstractMathJSONExpr\n\nRepresents a symbol (variable, constant, or function name) in MathJSON format.\n\nSymbol names are automatically normalized to Unicode NFC form for consistent comparison.\n\nFields\n\nname::String: The symbol name (NFC normalized)\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nSymbolExpr(name)                    # Simple symbol\nSymbolExpr(name; metadata=nothing)  # With optional metadata\n\nValid Identifier Formats\n\nStandard: alphanumeric + underscore (e.g., x, my_var, x1)\nBacktick-wrapped: for non-standard names (e.g., x+y, my var)\nPascalCase: for constants (e.g., Pi, ExponentialE)\n\nExamples\n\ns1 = SymbolExpr(\"x\")\ns2 = SymbolExpr(\"Pi\"; metadata=Dict(\"wikidata\" => \"Q167\"))\ns3 = SymbolExpr(\"`x+y`\")  # Non-standard identifier\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.StringExpr","page":"API Reference","title":"MathJSON.StringExpr","text":"StringExpr <: AbstractMathJSONExpr\n\nRepresents a string literal in MathJSON format.\n\nFields\n\nvalue::String: The string value\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nStringExpr(value)                    # Simple string\nStringExpr(value; metadata=nothing)  # With optional metadata\n\nExamples\n\ns1 = StringExpr(\"hello\")\ns2 = StringExpr(\"greeting\"; metadata=Dict(\"comment\" => \"A greeting\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.FunctionExpr","page":"API Reference","title":"MathJSON.FunctionExpr","text":"FunctionExpr <: AbstractMathJSONExpr\n\nRepresents a function application in MathJSON format.\n\nFields\n\noperator::Symbol: The function/operator name as a Julia Symbol\narguments::Vector{AbstractMathJSONExpr}: The function arguments\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nFunctionExpr(operator, arguments)                    # Basic construction\nFunctionExpr(operator, arguments; metadata=nothing)  # With optional metadata\n\nExamples\n\n# 1 + 2\nf1 = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\n\n# sin(x)\nf2 = FunctionExpr(:Sin, [SymbolExpr(\"x\")])\n\n# (1 + 2) * 3 (nested)\ninner = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\nouter = FunctionExpr(:Multiply, [inner, NumberExpr(3)])\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.parse-Tuple{Type{MathJSONFormat}, AbstractString}","page":"API Reference","title":"Base.parse","text":"parse(::Type{MathJSONFormat}, str::AbstractString) -> AbstractMathJSONExpr\n\nParse a MathJSON string into an expression tree.\n\nArguments\n\nstr: A valid MathJSON JSON string\n\nReturns\n\nAn expression tree (NumberExpr, SymbolExpr, StringExpr, or FunctionExpr)\n\nThrows\n\nMathJSONParseError: If the input is not valid MathJSON\n\nExamples\n\n# Parse a number\nparse(MathJSONFormat, \"42\")  # NumberExpr(42)\n\n# Parse a symbol\nparse(MathJSONFormat, \"\"x\"\")  # SymbolExpr(\"x\")\n\n# Parse a function\nparse(MathJSONFormat, \"[\"Add\", 1, 2]\")  # FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\n\n\n\n\n\n","category":"method"},{"location":"api/#MathJSON.generate","page":"API Reference","title":"MathJSON.generate","text":"generate(::Type{MathJSONFormat}, expr::AbstractMathJSONExpr; compact::Bool=true, pretty::Bool=false) -> String\n\nGenerate a MathJSON string from an expression tree.\n\nArguments\n\nexpr: A MathJSON expression tree\ncompact: If true (default), generate minimal JSON without unnecessary object forms\npretty: If true, generate formatted JSON with indentation (default: false)\n\nReturns\n\nA valid MathJSON JSON string\n\nExamples\n\n# Generate a number\ngenerate(MathJSONFormat, NumberExpr(42))  # \"42\"\n\n# Generate a symbol\ngenerate(MathJSONFormat, SymbolExpr(\"x\"))  # \"\"x\"\"\n\n# Generate a function\ngenerate(MathJSONFormat, FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)]))  # \"[\"Add\",1,2]\"\n\n# Generate with metadata (uses object form)\nexpr = NumberExpr(3.14; metadata=Dict(\"wikidata\" => \"Q167\"))\ngenerate(MathJSONFormat, expr)  # \"{\"num\":\"3.14\",\"wikidata\":\"Q167\"}\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.validate","page":"API Reference","title":"MathJSON.validate","text":"validate(expr::AbstractMathJSONExpr; strict::Bool=false) -> ValidationResult\n\nValidate a MathJSON expression against the specification.\n\nArguments\n\nexpr: The expression to validate\nstrict: If true, also check symbol naming conventions and operator names against the standard library\n\nReturns\n\nA ValidationResult with valid flag and errors vector\n\nStrict Mode Checks\n\nSymbol names should follow camelCase (variables) or PascalCase (constants)\nOperator names should be recognized standard library operators\nWildcards (starting with _) are only valid in specific contexts\n\nExamples\n\n# Basic validation\nresult = validate(NumberExpr(42))\nresult.valid  # true\n\n# Invalid structure\nresult = validate(FunctionExpr(:Add, []))  # Missing arguments\nresult.valid  # true (structurally valid, but semantically questionable)\n\n# Strict mode\nresult = validate(FunctionExpr(:CustomOp, [NumberExpr(1)]); strict=true)\nresult.errors  # [\"Unknown operator: CustomOp\"]\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.ValidationResult","page":"API Reference","title":"MathJSON.ValidationResult","text":"ValidationResult\n\nResult of validating a MathJSON expression.\n\nFields\n\nvalid::Bool: Whether the expression is valid\nerrors::Vector{String}: List of validation error messages (empty if valid)\n\nExamples\n\nresult = ValidationResult(true, String[])\nresult.valid  # true\nisempty(result.errors)  # true\n\nresult = ValidationResult(false, [\"Invalid operator: Foo\"])\nresult.valid  # false\nresult.errors  # [\"Invalid operator: Foo\"]\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.metadata","page":"API Reference","title":"MathJSON.metadata","text":"metadata(expr::AbstractMathJSONExpr)\n\nReturn the metadata dictionary associated with the expression, or nothing if no metadata is present.\n\nExamples\n\nn = NumberExpr(42; metadata=Dict(\"wikidata\" => \"Q167\"))\nmetadata(n)  # Dict{String, Any}(\"wikidata\" => \"Q167\")\n\ns = SymbolExpr(\"x\")\nmetadata(s)  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.with_metadata","page":"API Reference","title":"MathJSON.with_metadata","text":"with_metadata(expr, key::String, value) -> AbstractMathJSONExpr\n\nReturn a new expression with the given key-value pair added to its metadata. If the expression already has metadata, the new key-value is merged in. The original expression is not modified.\n\nExamples\n\nn = NumberExpr(42)\nn2 = with_metadata(n, \"wikidata\", \"Q167\")\nmetadata(n2)  # Dict{String, Any}(\"wikidata\" => \"Q167\")\nmetadata(n)   # nothing (original unchanged)\n\n\n\n\n\nwith_metadata(expr, metadata::Dict{String, Any}) -> AbstractMathJSONExpr\n\nReturn a new expression with the given metadata dictionary, replacing any existing metadata. The original expression is not modified.\n\nExamples\n\nn = NumberExpr(42; metadata=Dict(\"old\" => \"value\"))\nn2 = with_metadata(n, Dict{String, Any}(\"new\" => \"value\"))\nmetadata(n2)  # Dict{String, Any}(\"new\" => \"value\")\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.OperatorCategory","page":"API Reference","title":"MathJSON.OperatorCategory","text":"OperatorCategory\n\nModule containing the operator category enum. Use scoped access to avoid namespace pollution.\n\nExample\n\ncat = OperatorCategory.ARITHMETIC\ncat isa OperatorCategory.T  # true\n\n\n\n\n\n","category":"module"},{"location":"api/#MathJSON.OPERATORS","page":"API Reference","title":"MathJSON.OPERATORS","text":"OPERATORS::Dict{Symbol, OperatorCategory.T}\n\nDictionary mapping MathJSON operator symbols to their categories. Loaded from data/operators.json at module initialization.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MathJSON.JULIA_FUNCTIONS","page":"API Reference","title":"MathJSON.JULIA_FUNCTIONS","text":"JULIA_FUNCTIONS::Dict{Symbol, Function}\n\nDictionary mapping MathJSON operators to Julia functions. Used for converting MathJSON expressions to executable Julia code and for Symbolics.jl integration. Loaded from data/julia_functions.json at module initialization.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MathJSON.get_category","page":"API Reference","title":"MathJSON.get_category","text":"get_category(op::Symbol) -> OperatorCategory.T\n\nReturn the category for a MathJSON operator, or UNKNOWN if the operator is not recognized.\n\nExamples\n\nget_category(:Add)      # OperatorCategory.ARITHMETIC\nget_category(:Sin)      # OperatorCategory.TRIGONOMETRIC\nget_category(:Custom)   # OperatorCategory.UNKNOWN\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.get_julia_function","page":"API Reference","title":"MathJSON.get_julia_function","text":"get_julia_function(op::Symbol) -> Union{Function, Nothing}\n\nReturn the Julia function corresponding to a MathJSON operator, or nothing if no mapping exists.\n\nExamples\n\nget_julia_function(:Add)     # +\nget_julia_function(:Sin)     # sin\nget_julia_function(:Custom)  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.is_known_operator","page":"API Reference","title":"MathJSON.is_known_operator","text":"is_known_operator(op::Symbol) -> Bool\n\nReturn true if the operator is a known MathJSON standard library operator.\n\nExamples\n\nis_known_operator(:Add)     # true\nis_known_operator(:Sin)     # true\nis_known_operator(:Custom)  # false\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.to_symbolics","page":"API Reference","title":"MathJSON.to_symbolics","text":"to_symbolics(expr::AbstractMathJSONExpr)\n\nConvert a MathJSON expression to a Symbolics.jl expression.\n\nThis function requires the Symbolics.jl package to be loaded. Load it with using Symbolics before calling this function.\n\nExamples\n\nusing Symbolics\nexpr = parse(MathJSONFormat, \"[\"Add\", \"x\", 1]\")\nsymbolic = to_symbolics(expr)\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.from_symbolics","page":"API Reference","title":"MathJSON.from_symbolics","text":"from_symbolics(expr)\n\nConvert a Symbolics.jl expression to a MathJSON expression.\n\nThis function requires the Symbolics.jl package to be loaded. Load it with using Symbolics before calling this function.\n\nExamples\n\nusing Symbolics\n@variables x\nmathjson = from_symbolics(x + 1)\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.MathJSONParseError","page":"API Reference","title":"MathJSON.MathJSONParseError","text":"MathJSONParseError <: Exception\n\nException thrown when parsing invalid MathJSON input.\n\nFields\n\nmessage::String: Description of the parse error\nposition::Union{Nothing, Int}: Optional position in the input where error occurred\n\nExample\n\nthrow(MathJSONParseError(\"Unexpected token\", 42))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.UnsupportedConversionError","page":"API Reference","title":"MathJSON.UnsupportedConversionError","text":"UnsupportedConversionError <: Exception\n\nException thrown when attempting to convert an unsupported MathJSON expression to Symbolics.jl or vice versa.\n\nFields\n\nmessage::String: Description of the conversion error\n\nExample\n\nthrow(UnsupportedConversionError(\"Unknown operator: CustomOp\"))\n\n\n\n\n\n","category":"type"},{"location":"operators/#Operator-Registry","page":"Operator Registry","title":"Operator Registry","text":"MathJSON.jl uses a JSON-based registry system to define operators, their categories, and Julia function mappings. This design allows extending operator support without modifying Julia source code.","category":"section"},{"location":"operators/#File-Structure","page":"Operator Registry","title":"File Structure","text":"The registry consists of three JSON files in the data/ directory:\n\ndata/\n├── categories.json        # Category definitions\n├── operators.json         # Operator definitions with category references\n├── julia_functions.json   # Julia function mappings\n└── schemas/               # JSON Schema files for validation\n    ├── categories.schema.json\n    ├── operators.schema.json\n    └── julia_functions.schema.json","category":"section"},{"location":"operators/#Registry-File-Formats","page":"Operator Registry","title":"Registry File Formats","text":"","category":"section"},{"location":"operators/#categories.json","page":"Operator Registry","title":"categories.json","text":"Defines operator categories with unique identifiers, display names, and descriptions.\n\n{\n  \"categories\": [\n    {\n      \"id\": \"ARITHMETIC\",\n      \"name\": \"Arithmetic\",\n      \"description\": \"Basic math operations (+, -, *, /, ^)\"\n    }\n  ]\n}\n\nField Type Required Description\nid String Yes Uppercase identifier (e.g., \"ARITHMETIC\")\nname String Yes Human-readable display name\ndescription String Yes Brief description of the category","category":"section"},{"location":"operators/#operators.json","page":"Operator Registry","title":"operators.json","text":"Defines operators with their category assignments and optional metadata.\n\n{\n  \"operators\": [\n    {\n      \"name\": \"Add\",\n      \"category\": \"ARITHMETIC\",\n      \"arity\": \"variadic\",\n      \"description\": \"Addition of two or more values\",\n      \"aliases\": [\"Plus\", \"Sum\"]\n    }\n  ]\n}\n\nField Type Required Description\nname String Yes MathJSON operator name\ncategory String Yes Category ID (must exist in categories.json)\narity String/Integer No \"unary\", \"binary\", \"variadic\", or specific count\ndescription String No Brief description\naliases Array No Alternative operator names","category":"section"},{"location":"operators/#julia_functions.json","page":"Operator Registry","title":"julia_functions.json","text":"Maps operators to Julia functions for expression evaluation.\n\n{\n  \"mappings\": [\n    {\n      \"operator\": \"Add\",\n      \"julia_function\": \"+\",\n      \"module\": \"Base\"\n    },\n    {\n      \"operator\": \"And\",\n      \"julia_function\": null,\n      \"expression\": \"logical_and\"\n    }\n  ]\n}\n\nField Type Required Description\noperator String Yes Operator name (must exist in operators.json)\njulia_function String/null Yes Julia function name or null if unmapped\nmodule String No Module containing the function (default: \"Base\")\nexpression String No Key for special anonymous functions\n\nSpecial Functions: Some operators like And and Or require anonymous functions. These use the expression field to reference entries in the SPECIAL_FUNCTIONS dictionary:\n\nconst SPECIAL_FUNCTIONS = Dict{String,Function}(\n    \"logical_and\" => (a, b) -> a && b,\n    \"logical_or\" => (a, b) -> a || b\n)","category":"section"},{"location":"operators/#Adding-New-Operators","page":"Operator Registry","title":"Adding New Operators","text":"","category":"section"},{"location":"operators/#Step-1:-Add-Category-(if-needed)","page":"Operator Registry","title":"Step 1: Add Category (if needed)","text":"Add a new entry to data/categories.json:\n\n{\n  \"id\": \"MY_CATEGORY\",\n  \"name\": \"My Category\",\n  \"description\": \"Description of the category\"\n}\n\nNote: You must also add the category to the OperatorCategory.T enum in src/operators.jl and the CATEGORY_ENUM_MAP dictionary.","category":"section"},{"location":"operators/#Step-2:-Add-Operator","page":"Operator Registry","title":"Step 2: Add Operator","text":"Add a new entry to data/operators.json:\n\n{\n  \"name\": \"MyOperator\",\n  \"category\": \"MY_CATEGORY\",\n  \"arity\": \"binary\",\n  \"description\": \"What this operator does\"\n}","category":"section"},{"location":"operators/#Step-3:-Add-Julia-Function-Mapping","page":"Operator Registry","title":"Step 3: Add Julia Function Mapping","text":"Add a new entry to data/julia_functions.json:\n\n{\n  \"operator\": \"MyOperator\",\n  \"julia_function\": \"my_julia_function\",\n  \"module\": \"Base\"\n}\n\nFor operators without a direct Julia equivalent:\n\n{\n  \"operator\": \"MyOperator\",\n  \"julia_function\": null\n}\n\nFor operators requiring custom anonymous functions:\n\nAdd to SPECIAL_FUNCTIONS in src/registry_loader.jl:\n\"my_special\" => (a, b) -> custom_logic(a, b)\nReference in JSON:\n{\n  \"operator\": \"MyOperator\",\n  \"julia_function\": null,\n  \"expression\": \"my_special\"\n}","category":"section"},{"location":"operators/#Step-4:-Run-Tests","page":"Operator Registry","title":"Step 4: Run Tests","text":"Validate your changes pass schema validation and all tests:\n\njulia --project=. -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"operators/#Current-Operators","page":"Operator Registry","title":"Current Operators","text":"","category":"section"},{"location":"operators/#Arithmetic","page":"Operator Registry","title":"Arithmetic","text":"Operator Julia Function Arity Description\nAdd + variadic Addition\nSubtract - binary Subtraction\nMultiply * variadic Multiplication\nDivide / binary Division\nPower ^ binary Exponentiation\nNegate - unary Negation\nRoot - binary Nth root\nSqrt sqrt unary Square root\nAbs abs unary Absolute value","category":"section"},{"location":"operators/#Trigonometric","page":"Operator Registry","title":"Trigonometric","text":"Operator Julia Function Arity Description\nSin sin unary Sine\nCos cos unary Cosine\nTan tan unary Tangent\nArcsin asin unary Inverse sine\nArccos acos unary Inverse cosine\nArctan atan unary Inverse tangent\nSinh sinh unary Hyperbolic sine\nCosh cosh unary Hyperbolic cosine\nTanh tanh unary Hyperbolic tangent\nArcsinh asinh unary Inverse hyperbolic sine\nArccosh acosh unary Inverse hyperbolic cosine\nArctanh atanh unary Inverse hyperbolic tangent","category":"section"},{"location":"operators/#Logarithmic","page":"Operator Registry","title":"Logarithmic","text":"Operator Julia Function Arity Description\nLog log unary Natural logarithm\nLn log unary Natural logarithm (alias)\nExp exp unary Exponential (e^x)\nLog10 log10 unary Base-10 logarithm\nLog2 log2 unary Base-2 logarithm","category":"section"},{"location":"operators/#Comparison","page":"Operator Registry","title":"Comparison","text":"Operator Julia Function Arity Description\nEqual == binary Equality\nNotEqual != binary Inequality\nLess < binary Less than\nGreater > binary Greater than\nLessEqual <= binary Less than or equal\nGreaterEqual >= binary Greater than or equal","category":"section"},{"location":"operators/#Logical","page":"Operator Registry","title":"Logical","text":"Operator Julia Function Arity Description\nAnd (a, b) -> a && b variadic Logical AND\nOr (a, b) -> a || b variadic Logical OR\nNot ! unary Logical NOT","category":"section"},{"location":"operators/#Set","page":"Operator Registry","title":"Set","text":"Operator Julia Function Arity Description\nUnion union variadic Set union\nIntersection intersect variadic Set intersection\nSetMinus setdiff binary Set difference","category":"section"},{"location":"operators/#Calculus","page":"Operator Registry","title":"Calculus","text":"Operator Julia Function Arity Description\nDerivative - binary Derivative\nIntegrate - variadic Integral","category":"section"},{"location":"operators/#API-Reference","page":"Operator Registry","title":"API Reference","text":"See the API Reference page for documentation of operator-related functions (get_category, get_julia_function, is_known_operator) and types (OperatorCategory).","category":"section"},{"location":"operators/#Registry-Types","page":"Operator Registry","title":"Registry Types","text":"","category":"section"},{"location":"operators/#MathJSON.CategoryInfo","page":"Operator Registry","title":"MathJSON.CategoryInfo","text":"CategoryInfo\n\nStores information about an operator category loaded from JSON.\n\nFields\n\nid::String: Unique uppercase identifier (e.g., \"ARITHMETIC\")\nname::String: Human-readable display name\ndescription::String: Brief description of the category\n\n\n\n\n\n","category":"type"},{"location":"operators/#MathJSON.OperatorInfo","page":"Operator Registry","title":"MathJSON.OperatorInfo","text":"OperatorInfo\n\nStores information about an operator loaded from JSON.\n\nFields\n\nname::Symbol: Operator name as Symbol\ncategory::String: Category ID reference\narity::Union{String,Int,Nothing}: Operator arity\ndescription::Union{String,Nothing}: Operator description\naliases::Vector{String}: Alternative names\n\n\n\n\n\n","category":"type"},{"location":"operators/#MathJSON.RegistryLoadError","page":"Operator Registry","title":"MathJSON.RegistryLoadError","text":"RegistryLoadError <: Exception\n\nException raised when loading registry files fails.\n\nFields\n\npath::String: Path to the file that caused the error\ndetails::String: Detailed error message\n\n\n\n\n\n","category":"type"},{"location":"#MathJSON.jl","page":"Home","title":"MathJSON.jl","text":"A Julia package for parsing, manipulating, and generating mathematical expressions in the MathJSON format.\n\nMathJSON is a JSON-based format for representing mathematical expressions, providing interoperability with web-based mathematical tools like MathLive and the Cortex Compute Engine.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Parse MathJSON: Convert MathJSON strings to Julia expression trees\nGenerate MathJSON: Serialize Julia expressions to MathJSON format\nValidation: Verify expressions conform to the MathJSON specification\nSymbolics.jl Integration: Bidirectional conversion with Symbolics.jl expressions","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"MathJSON\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using MathJSON\n\n# Parse a MathJSON expression\nexpr = parse(MathJSONFormat, \"\"\"[\"Add\", 1, 2]\"\"\")\n\n# Generate MathJSON from an expression\njson = generate(MathJSONFormat, FunctionExpr(:Multiply, [NumberExpr(3), SymbolExpr(\"x\")]))\n\n# Validate an expression\nresult = validate(expr)","category":"section"},{"location":"#Symbolics.jl-Integration","page":"Home","title":"Symbolics.jl Integration","text":"MathJSON.jl provides seamless integration with Symbolics.jl:\n\nusing MathJSON\nusing Symbolics\n\n# Convert MathJSON to Symbolics\nexpr = parse(MathJSONFormat, \"\"\"[\"Add\", \"x\", 1]\"\"\")\nsymbolic = to_symbolics(expr)\n\n# Convert Symbolics to MathJSON\n@variables x\nmathjson = from_symbolics(x + 1)","category":"section"},{"location":"#API","page":"Home","title":"API","text":"See the API Reference page for complete documentation of all exported functions and types.","category":"section"}]
}
