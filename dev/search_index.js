var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Expression-Types","page":"API Reference","title":"Expression Types","text":"","category":"section"},{"location":"api/#Parsing","page":"API Reference","title":"Parsing","text":"","category":"section"},{"location":"api/#Generation","page":"API Reference","title":"Generation","text":"","category":"section"},{"location":"api/#Validation","page":"API Reference","title":"Validation","text":"","category":"section"},{"location":"api/#Metadata","page":"API Reference","title":"Metadata","text":"","category":"section"},{"location":"api/#Operators","page":"API Reference","title":"Operators","text":"","category":"section"},{"location":"api/#Symbolics.jl-Integration","page":"API Reference","title":"Symbolics.jl Integration","text":"","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#MathJSON.MathJSONFormat","page":"API Reference","title":"MathJSON.MathJSONFormat","text":"MathJSONFormat\n\nSingleton type used for dispatch in parse(MathJSONFormat, str) and generate(MathJSONFormat, expr) functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.AbstractMathJSONExpr","page":"API Reference","title":"MathJSON.AbstractMathJSONExpr","text":"AbstractMathJSONExpr\n\nAbstract base type for all MathJSON expression types.\n\nAll concrete expression types (NumberExpr, SymbolExpr, StringExpr, FunctionExpr) are subtypes of this abstract type, enabling dispatch-based polymorphism.\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.ExpressionType","page":"API Reference","title":"MathJSON.ExpressionType","text":"ExpressionType\n\nModule containing the expression type enum. Use scoped access to avoid namespace pollution.\n\nExample\n\nexpr_type = ExpressionType.NUMBER\nexpr_type isa ExpressionType.T  # true\n\n\n\n\n\n","category":"module"},{"location":"api/#MathJSON.NumberExpr","page":"API Reference","title":"MathJSON.NumberExpr","text":"NumberExpr <: AbstractMathJSONExpr\n\nRepresents a numeric value in MathJSON format.\n\nFields\n\nvalue::MathJSONNumber: The numeric value (Int64, Float64, BigFloat, or Rational)\nraw::Union{Nothing, String}: Original string representation for extended precision\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nNumberExpr(value)                        # Simple numeric value\nNumberExpr(value, raw)                   # With raw string for precision\nNumberExpr(value, raw, metadata)         # Full constructor\nNumberExpr(value; metadata=nothing)      # With keyword metadata\n\nExamples\n\nn1 = NumberExpr(42)\nn2 = NumberExpr(3.14, \"3.14159265358979323846\")\nn3 = NumberExpr(1//3)\nn4 = NumberExpr(3.14; metadata=Dict(\"wikidata\" => \"Q167\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.SymbolExpr","page":"API Reference","title":"MathJSON.SymbolExpr","text":"SymbolExpr <: AbstractMathJSONExpr\n\nRepresents a symbol (variable, constant, or function name) in MathJSON format.\n\nSymbol names are automatically normalized to Unicode NFC form for consistent comparison.\n\nFields\n\nname::String: The symbol name (NFC normalized)\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nSymbolExpr(name)                    # Simple symbol\nSymbolExpr(name; metadata=nothing)  # With optional metadata\n\nValid Identifier Formats\n\nStandard: alphanumeric + underscore (e.g., x, my_var, x1)\nBacktick-wrapped: for non-standard names (e.g., x+y, my var)\nPascalCase: for constants (e.g., Pi, ExponentialE)\n\nExamples\n\ns1 = SymbolExpr(\"x\")\ns2 = SymbolExpr(\"Pi\"; metadata=Dict(\"wikidata\" => \"Q167\"))\ns3 = SymbolExpr(\"`x+y`\")  # Non-standard identifier\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.StringExpr","page":"API Reference","title":"MathJSON.StringExpr","text":"StringExpr <: AbstractMathJSONExpr\n\nRepresents a string literal in MathJSON format.\n\nFields\n\nvalue::String: The string value\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nStringExpr(value)                    # Simple string\nStringExpr(value; metadata=nothing)  # With optional metadata\n\nExamples\n\ns1 = StringExpr(\"hello\")\ns2 = StringExpr(\"greeting\"; metadata=Dict(\"comment\" => \"A greeting\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.FunctionExpr","page":"API Reference","title":"MathJSON.FunctionExpr","text":"FunctionExpr <: AbstractMathJSONExpr\n\nRepresents a function application in MathJSON format.\n\nFields\n\noperator::Symbol: The function/operator name as a Julia Symbol\narguments::Vector{AbstractMathJSONExpr}: The function arguments\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nFunctionExpr(operator, arguments)                    # Basic construction\nFunctionExpr(operator, arguments; metadata=nothing)  # With optional metadata\n\nExamples\n\n# 1 + 2\nf1 = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\n\n# sin(x)\nf2 = FunctionExpr(:Sin, [SymbolExpr(\"x\")])\n\n# (1 + 2) * 3 (nested)\ninner = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\nouter = FunctionExpr(:Multiply, [inner, NumberExpr(3)])\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.parse-Tuple{Type{MathJSONFormat}, AbstractString}","page":"API Reference","title":"Base.parse","text":"parse(::Type{MathJSONFormat}, str::AbstractString) -> AbstractMathJSONExpr\n\nParse a MathJSON string into an expression tree.\n\nArguments\n\nstr: A valid MathJSON JSON string\n\nReturns\n\nAn expression tree (NumberExpr, SymbolExpr, StringExpr, or FunctionExpr)\n\nThrows\n\nMathJSONParseError: If the input is not valid MathJSON\n\nExamples\n\n# Parse a number\nparse(MathJSONFormat, \"42\")  # NumberExpr(42)\n\n# Parse a symbol\nparse(MathJSONFormat, \"\"x\"\")  # SymbolExpr(\"x\")\n\n# Parse a function\nparse(MathJSONFormat, \"[\"Add\", 1, 2]\")  # FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\n\n\n\n\n\n","category":"method"},{"location":"api/#MathJSON.generate","page":"API Reference","title":"MathJSON.generate","text":"generate(::Type{MathJSONFormat}, expr::AbstractMathJSONExpr; compact::Bool=true, pretty::Bool=false) -> String\n\nGenerate a MathJSON string from an expression tree.\n\nArguments\n\nexpr: A MathJSON expression tree\ncompact: If true (default), generate minimal JSON without unnecessary object forms\npretty: If true, generate formatted JSON with indentation (default: false)\n\nReturns\n\nA valid MathJSON JSON string\n\nExamples\n\n# Generate a number\ngenerate(MathJSONFormat, NumberExpr(42))  # \"42\"\n\n# Generate a symbol\ngenerate(MathJSONFormat, SymbolExpr(\"x\"))  # \"\"x\"\"\n\n# Generate a function\ngenerate(MathJSONFormat, FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)]))  # \"[\"Add\",1,2]\"\n\n# Generate with metadata (uses object form)\nexpr = NumberExpr(3.14; metadata=Dict(\"wikidata\" => \"Q167\"))\ngenerate(MathJSONFormat, expr)  # \"{\"num\":\"3.14\",\"wikidata\":\"Q167\"}\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.validate","page":"API Reference","title":"MathJSON.validate","text":"validate(expr::AbstractMathJSONExpr; strict::Bool=false) -> ValidationResult\n\nValidate a MathJSON expression against the specification.\n\nArguments\n\nexpr: The expression to validate\nstrict: If true, also check symbol naming conventions and operator names against the standard library\n\nReturns\n\nA ValidationResult with valid flag and errors vector\n\nStrict Mode Checks\n\nSymbol names should follow camelCase (variables) or PascalCase (constants)\nOperator names should be recognized standard library operators\nWildcards (starting with _) are only valid in specific contexts\n\nExamples\n\n# Basic validation\nresult = validate(NumberExpr(42))\nresult.valid  # true\n\n# Invalid structure\nresult = validate(FunctionExpr(:Add, []))  # Missing arguments\nresult.valid  # true (structurally valid, but semantically questionable)\n\n# Strict mode\nresult = validate(FunctionExpr(:CustomOp, [NumberExpr(1)]); strict=true)\nresult.errors  # [\"Unknown operator: CustomOp\"]\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.ValidationResult","page":"API Reference","title":"MathJSON.ValidationResult","text":"ValidationResult\n\nResult of validating a MathJSON expression.\n\nFields\n\nvalid::Bool: Whether the expression is valid\nerrors::Vector{String}: List of validation error messages (empty if valid)\n\nExamples\n\nresult = ValidationResult(true, String[])\nresult.valid  # true\nisempty(result.errors)  # true\n\nresult = ValidationResult(false, [\"Invalid operator: Foo\"])\nresult.valid  # false\nresult.errors  # [\"Invalid operator: Foo\"]\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.metadata","page":"API Reference","title":"MathJSON.metadata","text":"metadata(expr::AbstractMathJSONExpr)\n\nReturn the metadata dictionary associated with the expression, or nothing if no metadata is present.\n\nExamples\n\nn = NumberExpr(42; metadata=Dict(\"wikidata\" => \"Q167\"))\nmetadata(n)  # Dict{String, Any}(\"wikidata\" => \"Q167\")\n\ns = SymbolExpr(\"x\")\nmetadata(s)  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.with_metadata","page":"API Reference","title":"MathJSON.with_metadata","text":"with_metadata(expr, key::String, value) -> AbstractMathJSONExpr\n\nReturn a new expression with the given key-value pair added to its metadata. If the expression already has metadata, the new key-value is merged in. The original expression is not modified.\n\nExamples\n\nn = NumberExpr(42)\nn2 = with_metadata(n, \"wikidata\", \"Q167\")\nmetadata(n2)  # Dict{String, Any}(\"wikidata\" => \"Q167\")\nmetadata(n)   # nothing (original unchanged)\n\n\n\n\n\nwith_metadata(expr, metadata::Dict{String, Any}) -> AbstractMathJSONExpr\n\nReturn a new expression with the given metadata dictionary, replacing any existing metadata. The original expression is not modified.\n\nExamples\n\nn = NumberExpr(42; metadata=Dict(\"old\" => \"value\"))\nn2 = with_metadata(n, Dict{String, Any}(\"new\" => \"value\"))\nmetadata(n2)  # Dict{String, Any}(\"new\" => \"value\")\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.OperatorCategory","page":"API Reference","title":"MathJSON.OperatorCategory","text":"OperatorCategory\n\nModule containing the operator category enum. Use scoped access to avoid namespace pollution.\n\nExample\n\ncat = OperatorCategory.ARITHMETIC\ncat isa OperatorCategory.T  # true\n\n\n\n\n\n","category":"module"},{"location":"api/#MathJSON.OPERATORS","page":"API Reference","title":"MathJSON.OPERATORS","text":"OPERATORS::Dict{Symbol, OperatorCategory.T}\n\nDictionary mapping MathJSON operator symbols to their categories.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MathJSON.JULIA_FUNCTIONS","page":"API Reference","title":"MathJSON.JULIA_FUNCTIONS","text":"JULIA_FUNCTIONS::Dict{Symbol, Function}\n\nDictionary mapping MathJSON operators to Julia functions. Used for converting MathJSON expressions to executable Julia code and for Symbolics.jl integration.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MathJSON.get_category","page":"API Reference","title":"MathJSON.get_category","text":"get_category(op::Symbol) -> OperatorCategory.T\n\nReturn the category for a MathJSON operator, or UNKNOWN if the operator is not recognized.\n\nExamples\n\nget_category(:Add)      # OperatorCategory.ARITHMETIC\nget_category(:Sin)      # OperatorCategory.TRIGONOMETRIC\nget_category(:Custom)   # OperatorCategory.UNKNOWN\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.get_julia_function","page":"API Reference","title":"MathJSON.get_julia_function","text":"get_julia_function(op::Symbol) -> Union{Function, Nothing}\n\nReturn the Julia function corresponding to a MathJSON operator, or nothing if no mapping exists.\n\nExamples\n\nget_julia_function(:Add)     # +\nget_julia_function(:Sin)     # sin\nget_julia_function(:Custom)  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.is_known_operator","page":"API Reference","title":"MathJSON.is_known_operator","text":"is_known_operator(op::Symbol) -> Bool\n\nReturn true if the operator is a known MathJSON standard library operator.\n\nExamples\n\nis_known_operator(:Add)     # true\nis_known_operator(:Sin)     # true\nis_known_operator(:Custom)  # false\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.to_symbolics","page":"API Reference","title":"MathJSON.to_symbolics","text":"to_symbolics(expr::AbstractMathJSONExpr)\n\nConvert a MathJSON expression to a Symbolics.jl expression.\n\nThis function requires the Symbolics.jl package to be loaded. Load it with using Symbolics before calling this function.\n\nExamples\n\nusing Symbolics\nexpr = parse(MathJSONFormat, \"[\"Add\", \"x\", 1]\")\nsymbolic = to_symbolics(expr)\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.from_symbolics","page":"API Reference","title":"MathJSON.from_symbolics","text":"from_symbolics(expr)\n\nConvert a Symbolics.jl expression to a MathJSON expression.\n\nThis function requires the Symbolics.jl package to be loaded. Load it with using Symbolics before calling this function.\n\nExamples\n\nusing Symbolics\n@variables x\nmathjson = from_symbolics(x + 1)\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.MathJSONParseError","page":"API Reference","title":"MathJSON.MathJSONParseError","text":"MathJSONParseError <: Exception\n\nException thrown when parsing invalid MathJSON input.\n\nFields\n\nmessage::String: Description of the parse error\nposition::Union{Nothing, Int}: Optional position in the input where error occurred\n\nExample\n\nthrow(MathJSONParseError(\"Unexpected token\", 42))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.UnsupportedConversionError","page":"API Reference","title":"MathJSON.UnsupportedConversionError","text":"UnsupportedConversionError <: Exception\n\nException thrown when attempting to convert an unsupported MathJSON expression to Symbolics.jl or vice versa.\n\nFields\n\nmessage::String: Description of the conversion error\n\nExample\n\nthrow(UnsupportedConversionError(\"Unknown operator: CustomOp\"))\n\n\n\n\n\n","category":"type"},{"location":"#MathJSON.jl","page":"Home","title":"MathJSON.jl","text":"A Julia package for parsing, manipulating, and generating mathematical expressions in the MathJSON format.\n\nMathJSON is a JSON-based format for representing mathematical expressions, providing interoperability with web-based mathematical tools like MathLive and the Cortex Compute Engine.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Parse MathJSON: Convert MathJSON strings to Julia expression trees\nGenerate MathJSON: Serialize Julia expressions to MathJSON format\nValidation: Verify expressions conform to the MathJSON specification\nSymbolics.jl Integration: Bidirectional conversion with Symbolics.jl expressions","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"MathJSON\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using MathJSON\n\n# Parse a MathJSON expression\nexpr = parse(MathJSONFormat, \"\"\"[\"Add\", 1, 2]\"\"\")\n\n# Generate MathJSON from an expression\njson = generate(MathJSONFormat, FunctionExpr(:Multiply, [NumberExpr(3), SymbolExpr(\"x\")]))\n\n# Validate an expression\nresult = validate(expr)","category":"section"},{"location":"#Symbolics.jl-Integration","page":"Home","title":"Symbolics.jl Integration","text":"MathJSON.jl provides seamless integration with Symbolics.jl:\n\nusing MathJSON\nusing Symbolics\n\n# Convert MathJSON to Symbolics\nexpr = parse(MathJSONFormat, \"\"\"[\"Add\", \"x\", 1]\"\"\")\nsymbolic = to_symbolics(expr)\n\n# Convert Symbolics to MathJSON\n@variables x\nmathjson = from_symbolics(x + 1)","category":"section"},{"location":"#API","page":"Home","title":"API","text":"See the API Reference page for complete documentation of all exported functions and types.","category":"section"}]
}
