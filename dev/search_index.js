var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types","page":"API Reference","title":"Core Types","text":"","category":"section"},{"location":"api/#Expression-Types","page":"API Reference","title":"Expression Types","text":"","category":"section"},{"location":"api/#Parsing","page":"API Reference","title":"Parsing","text":"","category":"section"},{"location":"api/#Generation","page":"API Reference","title":"Generation","text":"","category":"section"},{"location":"api/#Validation","page":"API Reference","title":"Validation","text":"","category":"section"},{"location":"api/#Metadata","page":"API Reference","title":"Metadata","text":"","category":"section"},{"location":"api/#Operators","page":"API Reference","title":"Operators","text":"","category":"section"},{"location":"api/#Symbolics.jl-Integration","page":"API Reference","title":"Symbolics.jl Integration","text":"","category":"section"},{"location":"api/#Deprecated","page":"API Reference","title":"Deprecated","text":"from_symbolics(expr) — use to_mathjson(expr) instead.","category":"section"},{"location":"api/#Errors","page":"API Reference","title":"Errors","text":"","category":"section"},{"location":"api/#MathJSON.MathJSONFormat","page":"API Reference","title":"MathJSON.MathJSONFormat","text":"MathJSONFormat\n\nSingleton type used for dispatch in parse(MathJSONFormat, str) and generate(MathJSONFormat, expr) functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.AbstractMathJSONExpr","page":"API Reference","title":"MathJSON.AbstractMathJSONExpr","text":"AbstractMathJSONExpr\n\nAbstract base type for all MathJSON expression types.\n\nAll concrete expression types (NumberExpr, SymbolExpr, StringExpr, FunctionExpr) are subtypes of this abstract type, enabling dispatch-based polymorphism.\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.ExpressionType","page":"API Reference","title":"MathJSON.ExpressionType","text":"ExpressionType\n\nModule containing the expression type enum. Use scoped access to avoid namespace pollution.\n\nExample\n\nexpr_type = ExpressionType.NUMBER\nexpr_type isa ExpressionType.T  # true\n\n\n\n\n\n","category":"module"},{"location":"api/#MathJSON.NumberExpr","page":"API Reference","title":"MathJSON.NumberExpr","text":"NumberExpr <: AbstractMathJSONExpr\n\nRepresents a numeric value in MathJSON format.\n\nFields\n\nvalue::MathJSONNumber: The numeric value (Int64, Float64, BigFloat, or Rational)\nraw::Union{Nothing, String}: Original string representation for extended precision\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nNumberExpr(value)                        # Simple numeric value\nNumberExpr(value, raw)                   # With raw string for precision\nNumberExpr(value, raw, metadata)         # Full constructor\nNumberExpr(value; metadata=nothing)      # With keyword metadata\n\nExamples\n\nn1 = NumberExpr(42)\nn2 = NumberExpr(3.14, \"3.14159265358979323846\")\nn3 = NumberExpr(1//3)\nn4 = NumberExpr(3.14; metadata=Dict(\"wikidata\" => \"Q167\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.SymbolExpr","page":"API Reference","title":"MathJSON.SymbolExpr","text":"SymbolExpr <: AbstractMathJSONExpr\n\nRepresents a symbol (variable, constant, or function name) in MathJSON format.\n\nSymbol names are automatically normalized to Unicode NFC form for consistent comparison.\n\nFields\n\nname::String: The symbol name (NFC normalized)\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nSymbolExpr(name)                    # Simple symbol\nSymbolExpr(name; metadata=nothing)  # With optional metadata\n\nValid Identifier Formats\n\nStandard: alphanumeric + underscore (e.g., x, my_var, x1)\nBacktick-wrapped: for non-standard names (e.g., x+y, my var)\nPascalCase: for constants (e.g., Pi, ExponentialE)\n\nExamples\n\ns1 = SymbolExpr(\"x\")\ns2 = SymbolExpr(\"Pi\"; metadata=Dict(\"wikidata\" => \"Q167\"))\ns3 = SymbolExpr(\"`x+y`\")  # Non-standard identifier\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.StringExpr","page":"API Reference","title":"MathJSON.StringExpr","text":"StringExpr <: AbstractMathJSONExpr\n\nRepresents a string literal in MathJSON format.\n\nFields\n\nvalue::String: The string value\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nStringExpr(value)                    # Simple string\nStringExpr(value; metadata=nothing)  # With optional metadata\n\nExamples\n\ns1 = StringExpr(\"hello\")\ns2 = StringExpr(\"greeting\"; metadata=Dict(\"comment\" => \"A greeting\"))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.FunctionExpr","page":"API Reference","title":"MathJSON.FunctionExpr","text":"FunctionExpr <: AbstractMathJSONExpr\n\nRepresents a function application in MathJSON format.\n\nFields\n\noperator::Symbol: The function/operator name as a Julia Symbol\narguments::Vector{AbstractMathJSONExpr}: The function arguments\nmetadata::Union{Nothing, Dict{String, Any}}: Optional metadata dictionary\n\nConstructors\n\nFunctionExpr(operator, arguments)                    # Basic construction\nFunctionExpr(operator, arguments; metadata=nothing)  # With optional metadata\n\nExamples\n\n# 1 + 2\nf1 = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\n\n# sin(x)\nf2 = FunctionExpr(:Sin, [SymbolExpr(\"x\")])\n\n# (1 + 2) * 3 (nested)\ninner = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\nouter = FunctionExpr(:Multiply, [inner, NumberExpr(3)])\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.parse-Tuple{Type{MathJSONFormat}, AbstractString}","page":"API Reference","title":"Base.parse","text":"parse(::Type{MathJSONFormat}, str::AbstractString) -> AbstractMathJSONExpr\n\nParse a MathJSON string into an expression tree.\n\nArguments\n\nstr: A valid MathJSON JSON string\n\nReturns\n\nAn expression tree (NumberExpr, SymbolExpr, StringExpr, or FunctionExpr)\n\nThrows\n\nMathJSONParseError: If the input is not valid MathJSON\n\nExamples\n\n# Parse a number\nparse(MathJSONFormat, \"42\")  # NumberExpr(42)\n\n# Parse a symbol\nparse(MathJSONFormat, \"\"x\"\")  # SymbolExpr(\"x\")\n\n# Parse a function\nparse(MathJSONFormat, \"[\"Add\", 1, 2]\")  # FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])\n\n\n\n\n\n","category":"method"},{"location":"api/#MathJSON.generate","page":"API Reference","title":"MathJSON.generate","text":"generate(::Type{MathJSONFormat}, expr::AbstractMathJSONExpr; compact::Bool=true, pretty::Bool=false) -> String\n\nGenerate a MathJSON string from an expression tree.\n\nArguments\n\nexpr: A MathJSON expression tree\ncompact: If true (default), generate minimal JSON without unnecessary object forms\npretty: If true, generate formatted JSON with indentation (default: false)\n\nReturns\n\nA valid MathJSON JSON string\n\nExamples\n\n# Generate a number\ngenerate(MathJSONFormat, NumberExpr(42))  # \"42\"\n\n# Generate a symbol\ngenerate(MathJSONFormat, SymbolExpr(\"x\"))  # \"\"x\"\"\n\n# Generate a function\ngenerate(MathJSONFormat, FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)]))  # \"[\"Add\",1,2]\"\n\n# Generate with metadata (uses object form)\nexpr = NumberExpr(3.14; metadata=Dict(\"wikidata\" => \"Q167\"))\ngenerate(MathJSONFormat, expr)  # \"{\"num\":\"3.14\",\"wikidata\":\"Q167\"}\"\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.validate","page":"API Reference","title":"MathJSON.validate","text":"validate(expr::AbstractMathJSONExpr; strict::Bool=false) -> ValidationResult\n\nValidate a MathJSON expression against the specification.\n\nArguments\n\nexpr: The expression to validate\nstrict: If true, also check symbol naming conventions and operator names against the standard library\n\nReturns\n\nA ValidationResult with valid flag and errors vector\n\nStrict Mode Checks\n\nSymbol names should follow camelCase (variables) or PascalCase (constants)\nOperator names should be recognized standard library operators\nWildcards (starting with _) are only valid in specific contexts\n\nExamples\n\n# Basic validation\nresult = validate(NumberExpr(42))\nresult.valid  # true\n\n# Invalid structure\nresult = validate(FunctionExpr(:Add, []))  # Missing arguments\nresult.valid  # true (structurally valid, but semantically questionable)\n\n# Strict mode\nresult = validate(FunctionExpr(:CustomOp, [NumberExpr(1)]); strict=true)\nresult.errors  # [\"Unknown operator: CustomOp\"]\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.ValidationResult","page":"API Reference","title":"MathJSON.ValidationResult","text":"ValidationResult\n\nResult of validating a MathJSON expression.\n\nFields\n\nvalid::Bool: Whether the expression is valid\nerrors::Vector{String}: List of validation error messages (empty if valid)\n\nExamples\n\nresult = ValidationResult(true, String[])\nresult.valid  # true\nisempty(result.errors)  # true\n\nresult = ValidationResult(false, [\"Invalid operator: Foo\"])\nresult.valid  # false\nresult.errors  # [\"Invalid operator: Foo\"]\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.metadata","page":"API Reference","title":"MathJSON.metadata","text":"metadata(expr::AbstractMathJSONExpr)\n\nReturn the metadata dictionary associated with the expression, or nothing if no metadata is present.\n\nExamples\n\nn = NumberExpr(42; metadata=Dict(\"wikidata\" => \"Q167\"))\nmetadata(n)  # Dict{String, Any}(\"wikidata\" => \"Q167\")\n\ns = SymbolExpr(\"x\")\nmetadata(s)  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.with_metadata","page":"API Reference","title":"MathJSON.with_metadata","text":"with_metadata(expr, key::String, value) -> AbstractMathJSONExpr\n\nReturn a new expression with the given key-value pair added to its metadata. If the expression already has metadata, the new key-value is merged in. The original expression is not modified.\n\nExamples\n\nn = NumberExpr(42)\nn2 = with_metadata(n, \"wikidata\", \"Q167\")\nmetadata(n2)  # Dict{String, Any}(\"wikidata\" => \"Q167\")\nmetadata(n)   # nothing (original unchanged)\n\n\n\n\n\nwith_metadata(expr, metadata::Dict{String, Any}) -> AbstractMathJSONExpr\n\nReturn a new expression with the given metadata dictionary, replacing any existing metadata. The original expression is not modified.\n\nExamples\n\nn = NumberExpr(42; metadata=Dict(\"old\" => \"value\"))\nn2 = with_metadata(n, Dict{String, Any}(\"new\" => \"value\"))\nmetadata(n2)  # Dict{String, Any}(\"new\" => \"value\")\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.OperatorCategory","page":"API Reference","title":"MathJSON.OperatorCategory","text":"OperatorCategory\n\nModule containing the operator category enum. Use scoped access to avoid namespace pollution.\n\nExample\n\ncat = OperatorCategory.ARITHMETIC\ncat isa OperatorCategory.T  # true\n\n\n\n\n\n","category":"module"},{"location":"api/#MathJSON.OPERATORS","page":"API Reference","title":"MathJSON.OPERATORS","text":"OPERATORS::Dict{Symbol, OperatorCategory.T}\n\nDictionary mapping MathJSON operator symbols to their categories. Loaded from data/operators.json at module initialization.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MathJSON.JULIA_FUNCTIONS","page":"API Reference","title":"MathJSON.JULIA_FUNCTIONS","text":"JULIA_FUNCTIONS::Dict{Symbol, Function}\n\nDictionary mapping MathJSON operators to Julia functions. Used for converting MathJSON expressions to executable Julia code and for Symbolics.jl integration. Loaded from data/julia_functions.json at module initialization.\n\n\n\n\n\n","category":"constant"},{"location":"api/#MathJSON.get_category","page":"API Reference","title":"MathJSON.get_category","text":"get_category(op::Symbol) -> OperatorCategory.T\n\nReturn the category for a MathJSON operator, or UNKNOWN if the operator is not recognized.\n\nExamples\n\nget_category(:Add)      # OperatorCategory.ARITHMETIC\nget_category(:Sin)      # OperatorCategory.TRIGONOMETRY\nget_category(:Custom)   # OperatorCategory.UNKNOWN\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.get_julia_function","page":"API Reference","title":"MathJSON.get_julia_function","text":"get_julia_function(op::Symbol) -> Union{Function, Nothing}\n\nReturn the Julia function corresponding to a MathJSON operator, or nothing if no mapping exists.\n\nExamples\n\nget_julia_function(:Add)     # +\nget_julia_function(:Sin)     # sin\nget_julia_function(:Custom)  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.is_known_operator","page":"API Reference","title":"MathJSON.is_known_operator","text":"is_known_operator(op::Symbol) -> Bool\n\nReturn true if the operator is a known MathJSON standard library operator.\n\nExamples\n\nis_known_operator(:Add)     # true\nis_known_operator(:Sin)     # true\nis_known_operator(:Custom)  # false\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.to_symbolics","page":"API Reference","title":"MathJSON.to_symbolics","text":"to_symbolics(expr::AbstractMathJSONExpr)\n\nConvert a MathJSON expression to a Symbolics.jl expression.\n\nThis function requires the Symbolics.jl package to be loaded. Load it with using Symbolics before calling this function.\n\nExamples\n\nusing Symbolics\nexpr = parse(MathJSONFormat, \"[\"Add\", \"x\", 1]\")\nsymbolic = to_symbolics(expr)\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.to_mathjson","page":"API Reference","title":"MathJSON.to_mathjson","text":"to_mathjson(expr)\n\nConvert a Symbolics.jl expression to a MathJSON expression.\n\nThis function requires the Symbolics.jl package to be loaded. Load it with using Symbolics before calling this function.\n\nExamples\n\nusing Symbolics\n@variables x\nmathjson = to_mathjson(x + 1)\n\n\n\n\n\n","category":"function"},{"location":"api/#MathJSON.MathJSONParseError","page":"API Reference","title":"MathJSON.MathJSONParseError","text":"MathJSONParseError <: Exception\n\nException thrown when parsing invalid MathJSON input.\n\nFields\n\nmessage::String: Description of the parse error\nposition::Union{Nothing, Int}: Optional position in the input where error occurred\n\nExample\n\nthrow(MathJSONParseError(\"Unexpected token\", 42))\n\n\n\n\n\n","category":"type"},{"location":"api/#MathJSON.UnsupportedConversionError","page":"API Reference","title":"MathJSON.UnsupportedConversionError","text":"UnsupportedConversionError <: Exception\n\nException thrown when attempting to convert an unsupported MathJSON expression to Symbolics.jl or vice versa.\n\nFields\n\nmessage::String: Description of the conversion error\n\nExample\n\nthrow(UnsupportedConversionError(\"Unknown operator: CustomOp\"))\n\n\n\n\n\n","category":"type"},{"location":"operators/#Operator-Registry","page":"Operator Registry","title":"Operator Registry","text":"MathJSON.jl uses a JSON-based registry system based on the Cortex Compute Engine standard. The registry defines operators, their categories, and Julia function mappings.","category":"section"},{"location":"operators/#Cortex-Compute-Engine-Compatibility","page":"Operator Registry","title":"Cortex Compute Engine Compatibility","text":"The operator definitions are sourced from the Cortex Compute Engine's OPERATORS.json, providing full compatibility with the MathJSON standard library.","category":"section"},{"location":"operators/#File-Structure","page":"Operator Registry","title":"File Structure","text":"The registry consists of three JSON files in the data/ directory:\n\ndata/\n├── categories.json        # Category definitions\n├── operators.json         # Operator definitions (Cortex format)\n├── julia_functions.json   # Julia function mappings\n└── schemas/               # JSON Schema files for validation\n    ├── categories.schema.json\n    ├── operators.schema.json\n    └── julia_functions.schema.json","category":"section"},{"location":"operators/#Registry-File-Formats","page":"Operator Registry","title":"Registry File Formats","text":"","category":"section"},{"location":"operators/#categories.json","page":"Operator Registry","title":"categories.json","text":"Defines operator categories matching the Cortex Compute Engine standard.\n\n{\n  \"categories\": [\n    {\n      \"id\": \"Arithmetic\",\n      \"name\": \"Arithmetic\",\n      \"description\": \"Basic arithmetic operations and functions\"\n    }\n  ]\n}\n\nField Type Required Description\nid String Yes Category identifier (e.g., \"Arithmetic\", \"Trigonometry\")\nname String Yes Human-readable display name\ndescription String Yes Brief description of the category","category":"section"},{"location":"operators/#operators.json","page":"Operator Registry","title":"operators.json","text":"Defines operators using the Cortex Compute Engine format with full metadata.\n\n{\n  \"operators\": [\n    {\n      \"name\": \"Add\",\n      \"category\": \"Arithmetic\",\n      \"arity\": \"variadic\",\n      \"signature\": \"(value+) -> value\",\n      \"associative\": true,\n      \"commutative\": true,\n      \"idempotent\": true,\n      \"lazy\": true,\n      \"broadcastable\": true,\n      \"description\": \"Sum of two or more values.\",\n      \"wikidata\": \"Q32043\"\n    }\n  ]\n}\n\nField Type Required Description\nname String Yes MathJSON operator name\ncategory String Yes Category ID (must exist in categories.json)\narity String No \"1\", \"2\", \"variadic\", \"1+\", \"2+\", etc.\nsignature String No Type signature (e.g., \"(number, number) -> number\")\nassociative Boolean No Whether the operator is associative\ncommutative Boolean No Whether the operator is commutative\nidempotent Boolean No Whether the operator is idempotent\nlazy Boolean No Whether the operator uses lazy evaluation\nbroadcastable Boolean No Whether the operator can be broadcast\ndescription String No Brief description\nwikidata String No Wikidata identifier (e.g., \"Q32043\")\nexamples Array No Example expressions as strings","category":"section"},{"location":"operators/#julia_functions.json","page":"Operator Registry","title":"julia_functions.json","text":"Maps operators to Julia functions for expression evaluation.\n\n{\n  \"mappings\": [\n    {\n      \"operator\": \"Add\",\n      \"julia_function\": \"+\",\n      \"module\": \"Base\"\n    },\n    {\n      \"operator\": \"And\",\n      \"julia_function\": null,\n      \"expression\": \"logical_and\"\n    }\n  ]\n}\n\nField Type Required Description\noperator String Yes Operator name (must exist in operators.json)\njulia_function String/null Yes Julia function name or null if unmapped\nmodule String No Module containing the function (default: \"Base\")\nexpression String No Key for special anonymous functions\n\nSpecial Functions: Some operators like And and Or require anonymous functions. These use the expression field to reference entries in the SPECIAL_FUNCTIONS dictionary:\n\nconst SPECIAL_FUNCTIONS = Dict{String,Function}(\n    \"logical_and\" => (a, b) -> a && b,\n    \"logical_or\" => (a, b) -> a || b,\n    \"logical_nand\" => (a, b) -> !(a && b),\n    \"logical_nor\" => (a, b) -> !(a || b),\n    \"logical_implies\" => (a, b) -> !a || b,\n    \"logical_equivalent\" => (a, b) -> a == b,\n    \"square\" => x -> x^2,\n    \"nth_root\" => (x, n) -> x^(1/n),\n    # ... and more\n)","category":"section"},{"location":"operators/#Categories","page":"Operator Registry","title":"Categories","text":"MathJSON.jl supports all 15 Cortex Compute Engine categories:\n\nCategory Description\nArithmetic Basic arithmetic operations and functions\nCalculus Calculus operations (derivatives, integrals, limits)\nCollections Operations on collections (lists, sequences, sets)\nColors Color manipulation and conversion operations\nCombinatorics Combinatorial functions (factorial, binomial, permutations)\nControl Structures Control flow structures (if, loop, block)\nCore Core language constructs and meta-operations\nLinear Algebra Linear algebra operations (matrix, vector, decompositions)\nLogic Logical operators and predicates\nNumber Theory Number theory functions (gcd, lcm, prime, divisibility)\nPolynomials Polynomial arithmetic and manipulation\nRelational Operators Comparison and relational operators\nStatistics Statistical functions (mean, variance, distributions)\nTrigonometry Trigonometric and hyperbolic functions\nUnits Physical units and quantity operations","category":"section"},{"location":"operators/#Selected-Operators-by-Category","page":"Operator Registry","title":"Selected Operators by Category","text":"","category":"section"},{"location":"operators/#Arithmetic-(Sample)","page":"Operator Registry","title":"Arithmetic (Sample)","text":"Operator Julia Function Arity Description\nAdd + variadic Sum of two or more values\nSubtract - 2 Subtraction\nMultiply * variadic Multiplication\nDivide / 2 Division\nPower ^ 2 Exponentiation\nNegate - 1 Negation\nSqrt sqrt 1 Square root\nAbs abs 1 Absolute value\nExp exp 1 Exponential (e^x)\nLn log 1 Natural logarithm\nLog log 1-2 Logarithm\nLog10 log10 1 Base-10 logarithm\nLog2 log2 1 Base-2 logarithm","category":"section"},{"location":"operators/#Trigonometry-(Sample)","page":"Operator Registry","title":"Trigonometry (Sample)","text":"Operator Julia Function Arity Description\nSin sin 1 Sine\nCos cos 1 Cosine\nTan tan 1 Tangent\nArcsin asin 1 Inverse sine\nArccos acos 1 Inverse cosine\nArctan atan 1 Inverse tangent\nSinh sinh 1 Hyperbolic sine\nCosh cosh 1 Hyperbolic cosine\nTanh tanh 1 Hyperbolic tangent\nArsinh asinh 1 Inverse hyperbolic sine\nArcosh acosh 1 Inverse hyperbolic cosine\nArtanh atanh 1 Inverse hyperbolic tangent","category":"section"},{"location":"operators/#Relational-Operators","page":"Operator Registry","title":"Relational Operators","text":"Operator Julia Function Arity Description\nEqual == 2 Equality\nNotEqual != 2 Inequality\nLess < 2 Less than\nGreater > 2 Greater than\nLessEqual <= 2 Less than or equal\nGreaterEqual >= 2 Greater than or equal\nApproxEqual isapprox 2 Approximate equality","category":"section"},{"location":"operators/#Logic","page":"Operator Registry","title":"Logic","text":"Operator Julia Function Arity Description\nAnd (a, b) -> a && b variadic Logical AND\nOr (a, b) -> a || b variadic Logical OR\nNot ! 1 Logical NOT\nXor xor 2 Exclusive OR\nNand (a, b) -> !(a && b) 2 NOT AND\nNor (a, b) -> !(a || b) 2 NOT OR\nImplies (a, b) -> !a || b 2 Logical implication\nEquivalent (a, b) -> a == b 2 Logical equivalence","category":"section"},{"location":"operators/#Collections-(Sample)","page":"Operator Registry","title":"Collections (Sample)","text":"Operator Julia Function Arity Description\nUnion union variadic Set union\nIntersection intersect variadic Set intersection\nSetMinus setdiff 2 Set difference\nFirst first 1 First element\nLast last 1 Last element\nReverse reverse 1 Reverse collection\nSort sort 1 Sort collection\nUnique unique 1 Unique elements","category":"section"},{"location":"operators/#Calculus","page":"Operator Registry","title":"Calculus","text":"Operator Julia Function Arity Description\nD - 1-2 Derivative\nND - 1+ Numerical derivative\nIntegrate - 1+ Integral\nNIntegrate - 1+ Numerical integration\nLimit - 2+ Limit\nSum sum 1+ Summation\nProduct prod 1+ Product","category":"section"},{"location":"operators/#Linear-Algebra-(Sample)","page":"Operator Registry","title":"Linear Algebra (Sample)","text":"Operator Julia Function Arity Description\nDeterminant det 1 Matrix determinant\nTranspose transpose 1 Matrix transpose\nInverse inv 1 Matrix inverse\nTrace tr 1 Matrix trace\nNorm norm 1 Vector/matrix norm\nRank rank 1 Matrix rank\nEigenvalues eigvals 1 Eigenvalues\nEigenvectors eigvecs 1 Eigenvectors","category":"section"},{"location":"operators/#Statistics-(Sample)","page":"Operator Registry","title":"Statistics (Sample)","text":"Operator Julia Function Arity Description\nMean mean 1 Arithmetic mean\nMedian median 1 Median value\nVariance var 1 Variance\nStandardDeviation std 1 Standard deviation\nMin min variadic Minimum\nMax max variadic Maximum","category":"section"},{"location":"operators/#Combinatorics-(Sample)","page":"Operator Registry","title":"Combinatorics (Sample)","text":"Operator Julia Function Arity Description\nFactorial factorial 1 Factorial\nBinomial binomial 2 Binomial coefficient\nGCD gcd 2+ Greatest common divisor\nLCM lcm 2+ Least common multiple","category":"section"},{"location":"operators/#Adding-New-Operators","page":"Operator Registry","title":"Adding New Operators","text":"","category":"section"},{"location":"operators/#Step-1:-Add-Category-(if-needed)","page":"Operator Registry","title":"Step 1: Add Category (if needed)","text":"Add a new entry to data/categories.json:\n\n{\n  \"id\": \"MyCategory\",\n  \"name\": \"My Category\",\n  \"description\": \"Description of the category\"\n}\n\nNote: You must also add the category to the OperatorCategory.T enum in src/operators.jl and the CATEGORY_ENUM_MAP dictionary.","category":"section"},{"location":"operators/#Step-2:-Add-Operator","page":"Operator Registry","title":"Step 2: Add Operator","text":"Add a new entry to data/operators.json:\n\n{\n  \"name\": \"MyOperator\",\n  \"category\": \"MyCategory\",\n  \"arity\": \"2\",\n  \"signature\": \"(number, number) -> number\",\n  \"associative\": false,\n  \"commutative\": true,\n  \"idempotent\": false,\n  \"lazy\": false,\n  \"broadcastable\": true,\n  \"description\": \"What this operator does\"\n}","category":"section"},{"location":"operators/#Step-3:-Add-Julia-Function-Mapping","page":"Operator Registry","title":"Step 3: Add Julia Function Mapping","text":"Add a new entry to data/julia_functions.json:\n\n{\n  \"operator\": \"MyOperator\",\n  \"julia_function\": \"my_julia_function\",\n  \"module\": \"Base\"\n}\n\nFor operators without a direct Julia equivalent:\n\n{\n  \"operator\": \"MyOperator\",\n  \"julia_function\": null\n}\n\nFor operators requiring custom anonymous functions:\n\nAdd to SPECIAL_FUNCTIONS in src/registry_loader.jl:\n\"my_special\" => (a, b) -> custom_logic(a, b)\nReference in JSON:\n{\n  \"operator\": \"MyOperator\",\n  \"julia_function\": null,\n  \"expression\": \"my_special\"\n}","category":"section"},{"location":"operators/#Step-4:-Run-Tests","page":"Operator Registry","title":"Step 4: Run Tests","text":"Validate your changes pass schema validation and all tests:\n\njulia --project=. -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"operators/#API-Reference","page":"Operator Registry","title":"API Reference","text":"See the API Reference page for documentation of operator-related functions (get_category, get_julia_function, is_known_operator) and types (OperatorCategory).","category":"section"},{"location":"operators/#Registry-Types","page":"Operator Registry","title":"Registry Types","text":"","category":"section"},{"location":"operators/#MathJSON.CategoryInfo","page":"Operator Registry","title":"MathJSON.CategoryInfo","text":"CategoryInfo\n\nStores information about an operator category loaded from JSON.\n\nFields\n\nid::String: Category identifier (e.g., \"Arithmetic\")\nname::String: Human-readable display name\ndescription::String: Brief description of the category\n\n\n\n\n\n","category":"type"},{"location":"operators/#MathJSON.OperatorInfo","page":"Operator Registry","title":"MathJSON.OperatorInfo","text":"OperatorInfo\n\nStores information about an operator loaded from JSON. Compatible with Cortex Compute Engine OPERATORS.json format.\n\nFields\n\nname::Symbol: Operator name as Symbol\ncategory::String: Category name reference\narity::Union{String,Nothing}: Operator arity (e.g., \"1\", \"2\", \"variadic\")\nsignature::Union{String,Nothing}: Type signature (e.g., \"(number, number) -> number\")\nassociative::Bool: Whether the operator is associative\ncommutative::Bool: Whether the operator is commutative\nidempotent::Bool: Whether the operator is idempotent\nlazy::Bool: Whether the operator uses lazy evaluation\nbroadcastable::Bool: Whether the operator can be broadcast\ndescription::Union{String,Nothing}: Operator description\nwikidata::Union{String,Nothing}: Wikidata identifier\n\n\n\n\n\n","category":"type"},{"location":"operators/#MathJSON.RegistryLoadError","page":"Operator Registry","title":"MathJSON.RegistryLoadError","text":"RegistryLoadError <: Exception\n\nException raised when loading registry files fails.\n\nFields\n\npath::String: Path to the file that caused the error\ndetails::String: Detailed error message\n\n\n\n\n\n","category":"type"},{"location":"#MathJSON.jl","page":"Home","title":"MathJSON.jl","text":"A Julia package for parsing, manipulating, and generating mathematical expressions in the MathJSON format.\n\nMathJSON is a JSON-based format for representing mathematical expressions, providing interoperability with web-based mathematical tools like MathLive and the Cortex Compute Engine.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Parse MathJSON: Convert MathJSON strings to Julia expression trees\nGenerate MathJSON: Serialize Julia expressions to MathJSON format\nValidation: Verify expressions conform to the MathJSON specification\nSymbolics.jl Integration: Bidirectional conversion with Symbolics.jl expressions\nCortex Compute Engine Compatible: Full support for all 382 operators from the official MathJSON standard library","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"MathJSON\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using MathJSON\n\n# Parse a MathJSON expression\nexpr = parse(MathJSONFormat, \"\"\"[\"Add\", 1, 2]\"\"\")\n\n# Generate MathJSON from an expression\njson = generate(MathJSONFormat, FunctionExpr(:Multiply, [NumberExpr(3), SymbolExpr(\"x\")]))\n\n# Validate an expression\nresult = validate(expr)","category":"section"},{"location":"#Symbolics.jl-Integration","page":"Home","title":"Symbolics.jl Integration","text":"MathJSON.jl provides seamless integration with Symbolics.jl:\n\nusing MathJSON\nusing Symbolics\n\n# Convert MathJSON to Symbolics\nexpr = parse(MathJSONFormat, \"\"\"[\"Add\", \"x\", 1]\"\"\")\nsymbolic = to_symbolics(expr)\n\n# Convert Symbolics to MathJSON\n@variables x\nmathjson = to_mathjson(x + 1)","category":"section"},{"location":"#Operator-Registry","page":"Home","title":"Operator Registry","text":"MathJSON.jl includes an extensive operator registry based on the Cortex Compute Engine standard library:\n\n382 operators across 15 categories\nArithmetic: Add, Subtract, Multiply, Divide, Power, Sqrt, Abs, Exp, Log, ...\nTrigonometry: Sin, Cos, Tan, Arcsin, Arccos, Arctan, Sinh, Cosh, ...\nCalculus: D (derivative), Integrate, Limit, Sum, Product, ...\nLinear Algebra: Determinant, Transpose, Inverse, Eigenvalues, ...\nLogic: And, Or, Not, Xor, Implies, Equivalent, ...\nStatistics: Mean, Median, Variance, StandardDeviation, ...\nAnd more: Collections, Combinatorics, Number Theory, Polynomials, ...\n\nSee the Operator Registry page for complete documentation.","category":"section"},{"location":"#API","page":"Home","title":"API","text":"See the API Reference page for complete documentation of all exported functions and types.","category":"section"}]
}
