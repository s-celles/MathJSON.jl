<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MathJSON.jl</title><meta name="title" content="API Reference · MathJSON.jl"/><meta property="og:title" content="API Reference · MathJSON.jl"/><meta property="twitter:title" content="API Reference · MathJSON.jl"/><meta name="description" content="Documentation for MathJSON.jl."/><meta property="og:description" content="Documentation for MathJSON.jl."/><meta property="twitter:description" content="Documentation for MathJSON.jl."/><meta property="og:url" content="https://s-celles.github.io/MathJSON.jl/api/"/><meta property="twitter:url" content="https://s-celles.github.io/MathJSON.jl/api/"/><link rel="canonical" href="https://s-celles.github.io/MathJSON.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MathJSON.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../operators/">Operator Registry</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Core-Types"><span>Core Types</span></a></li><li><a class="tocitem" href="#Expression-Types"><span>Expression Types</span></a></li><li><a class="tocitem" href="#Parsing"><span>Parsing</span></a></li><li><a class="tocitem" href="#Generation"><span>Generation</span></a></li><li><a class="tocitem" href="#Validation"><span>Validation</span></a></li><li><a class="tocitem" href="#Metadata"><span>Metadata</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Symbolics.jl-Integration"><span>Symbolics.jl Integration</span></a></li><li><a class="tocitem" href="#Errors"><span>Errors</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/s-celles/MathJSON.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.MathJSONFormat"><a class="docstring-binding" href="#MathJSON.MathJSONFormat"><code>MathJSON.MathJSONFormat</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MathJSONFormat</code></pre><p>Singleton type used for dispatch in <code>parse(MathJSONFormat, str)</code> and <code>generate(MathJSONFormat, expr)</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.AbstractMathJSONExpr"><a class="docstring-binding" href="#MathJSON.AbstractMathJSONExpr"><code>MathJSON.AbstractMathJSONExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMathJSONExpr</code></pre><p>Abstract base type for all MathJSON expression types.</p><p>All concrete expression types (<code>NumberExpr</code>, <code>SymbolExpr</code>, <code>StringExpr</code>, <code>FunctionExpr</code>) are subtypes of this abstract type, enabling dispatch-based polymorphism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.ExpressionType"><a class="docstring-binding" href="#MathJSON.ExpressionType"><code>MathJSON.ExpressionType</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">ExpressionType</code></pre><p>Module containing the expression type enum. Use scoped access to avoid namespace pollution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">expr_type = ExpressionType.NUMBER
expr_type isa ExpressionType.T  # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Expression-Types"><a class="docs-heading-anchor" href="#Expression-Types">Expression Types</a><a id="Expression-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.NumberExpr"><a class="docstring-binding" href="#MathJSON.NumberExpr"><code>MathJSON.NumberExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NumberExpr &lt;: AbstractMathJSONExpr</code></pre><p>Represents a numeric value in MathJSON format.</p><p><strong>Fields</strong></p><ul><li><code>value::MathJSONNumber</code>: The numeric value (Int64, Float64, BigFloat, or Rational)</li><li><code>raw::Union{Nothing, String}</code>: Original string representation for extended precision</li><li><code>metadata::Union{Nothing, Dict{String, Any}}</code>: Optional metadata dictionary</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">NumberExpr(value)                        # Simple numeric value
NumberExpr(value, raw)                   # With raw string for precision
NumberExpr(value, raw, metadata)         # Full constructor
NumberExpr(value; metadata=nothing)      # With keyword metadata</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">n1 = NumberExpr(42)
n2 = NumberExpr(3.14, &quot;3.14159265358979323846&quot;)
n3 = NumberExpr(1//3)
n4 = NumberExpr(3.14; metadata=Dict(&quot;wikidata&quot; =&gt; &quot;Q167&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.SymbolExpr"><a class="docstring-binding" href="#MathJSON.SymbolExpr"><code>MathJSON.SymbolExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SymbolExpr &lt;: AbstractMathJSONExpr</code></pre><p>Represents a symbol (variable, constant, or function name) in MathJSON format.</p><p>Symbol names are automatically normalized to Unicode NFC form for consistent comparison.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: The symbol name (NFC normalized)</li><li><code>metadata::Union{Nothing, Dict{String, Any}}</code>: Optional metadata dictionary</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SymbolExpr(name)                    # Simple symbol
SymbolExpr(name; metadata=nothing)  # With optional metadata</code></pre><p><strong>Valid Identifier Formats</strong></p><ul><li>Standard: alphanumeric + underscore (e.g., <code>x</code>, <code>my_var</code>, <code>x1</code>)</li><li>Backtick-wrapped: for non-standard names (e.g., <span>$`x+y`$</span>, <span>$`my var`$</span>)</li><li>PascalCase: for constants (e.g., <code>Pi</code>, <code>ExponentialE</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">s1 = SymbolExpr(&quot;x&quot;)
s2 = SymbolExpr(&quot;Pi&quot;; metadata=Dict(&quot;wikidata&quot; =&gt; &quot;Q167&quot;))
s3 = SymbolExpr(&quot;`x+y`&quot;)  # Non-standard identifier</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.StringExpr"><a class="docstring-binding" href="#MathJSON.StringExpr"><code>MathJSON.StringExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StringExpr &lt;: AbstractMathJSONExpr</code></pre><p>Represents a string literal in MathJSON format.</p><p><strong>Fields</strong></p><ul><li><code>value::String</code>: The string value</li><li><code>metadata::Union{Nothing, Dict{String, Any}}</code>: Optional metadata dictionary</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">StringExpr(value)                    # Simple string
StringExpr(value; metadata=nothing)  # With optional metadata</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs">s1 = StringExpr(&quot;hello&quot;)
s2 = StringExpr(&quot;greeting&quot;; metadata=Dict(&quot;comment&quot; =&gt; &quot;A greeting&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.FunctionExpr"><a class="docstring-binding" href="#MathJSON.FunctionExpr"><code>MathJSON.FunctionExpr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FunctionExpr &lt;: AbstractMathJSONExpr</code></pre><p>Represents a function application in MathJSON format.</p><p><strong>Fields</strong></p><ul><li><code>operator::Symbol</code>: The function/operator name as a Julia Symbol</li><li><code>arguments::Vector{AbstractMathJSONExpr}</code>: The function arguments</li><li><code>metadata::Union{Nothing, Dict{String, Any}}</code>: Optional metadata dictionary</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">FunctionExpr(operator, arguments)                    # Basic construction
FunctionExpr(operator, arguments; metadata=nothing)  # With optional metadata</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 1 + 2
f1 = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])

# sin(x)
f2 = FunctionExpr(:Sin, [SymbolExpr(&quot;x&quot;)])

# (1 + 2) * 3 (nested)
inner = FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])
outer = FunctionExpr(:Multiply, [inner, NumberExpr(3)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing">Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Base.parse-Tuple{Type{MathJSONFormat}, AbstractString}"><a class="docstring-binding" href="#Base.parse-Tuple{Type{MathJSONFormat}, AbstractString}"><code>Base.parse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse(::Type{MathJSONFormat}, str::AbstractString) -&gt; AbstractMathJSONExpr</code></pre><p>Parse a MathJSON string into an expression tree.</p><p><strong>Arguments</strong></p><ul><li><code>str</code>: A valid MathJSON JSON string</li></ul><p><strong>Returns</strong></p><p>An expression tree (<code>NumberExpr</code>, <code>SymbolExpr</code>, <code>StringExpr</code>, or <code>FunctionExpr</code>)</p><p><strong>Throws</strong></p><ul><li><code>MathJSONParseError</code>: If the input is not valid MathJSON</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Parse a number
parse(MathJSONFormat, &quot;42&quot;)  # NumberExpr(42)

# Parse a symbol
parse(MathJSONFormat, &quot;&quot;x&quot;&quot;)  # SymbolExpr(&quot;x&quot;)

# Parse a function
parse(MathJSONFormat, &quot;[&quot;Add&quot;, 1, 2]&quot;)  # FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Generation"><a class="docs-heading-anchor" href="#Generation">Generation</a><a id="Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Generation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.generate"><a class="docstring-binding" href="#MathJSON.generate"><code>MathJSON.generate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">generate(::Type{MathJSONFormat}, expr::AbstractMathJSONExpr; compact::Bool=true, pretty::Bool=false) -&gt; String</code></pre><p>Generate a MathJSON string from an expression tree.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: A MathJSON expression tree</li><li><code>compact</code>: If <code>true</code> (default), generate minimal JSON without unnecessary object forms</li><li><code>pretty</code>: If <code>true</code>, generate formatted JSON with indentation (default: <code>false</code>)</li></ul><p><strong>Returns</strong></p><p>A valid MathJSON JSON string</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Generate a number
generate(MathJSONFormat, NumberExpr(42))  # &quot;42&quot;

# Generate a symbol
generate(MathJSONFormat, SymbolExpr(&quot;x&quot;))  # &quot;&quot;x&quot;&quot;

# Generate a function
generate(MathJSONFormat, FunctionExpr(:Add, [NumberExpr(1), NumberExpr(2)]))  # &quot;[&quot;Add&quot;,1,2]&quot;

# Generate with metadata (uses object form)
expr = NumberExpr(3.14; metadata=Dict(&quot;wikidata&quot; =&gt; &quot;Q167&quot;))
generate(MathJSONFormat, expr)  # &quot;{&quot;num&quot;:&quot;3.14&quot;,&quot;wikidata&quot;:&quot;Q167&quot;}&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Validation"><a class="docs-heading-anchor" href="#Validation">Validation</a><a id="Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Validation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.validate"><a class="docstring-binding" href="#MathJSON.validate"><code>MathJSON.validate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">validate(expr::AbstractMathJSONExpr; strict::Bool=false) -&gt; ValidationResult</code></pre><p>Validate a MathJSON expression against the specification.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: The expression to validate</li><li><code>strict</code>: If <code>true</code>, also check symbol naming conventions and operator names against the standard library</li></ul><p><strong>Returns</strong></p><p>A <code>ValidationResult</code> with <code>valid</code> flag and <code>errors</code> vector</p><p><strong>Strict Mode Checks</strong></p><ul><li>Symbol names should follow camelCase (variables) or PascalCase (constants)</li><li>Operator names should be recognized standard library operators</li><li>Wildcards (starting with <code>_</code>) are only valid in specific contexts</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic validation
result = validate(NumberExpr(42))
result.valid  # true

# Invalid structure
result = validate(FunctionExpr(:Add, []))  # Missing arguments
result.valid  # true (structurally valid, but semantically questionable)

# Strict mode
result = validate(FunctionExpr(:CustomOp, [NumberExpr(1)]); strict=true)
result.errors  # [&quot;Unknown operator: CustomOp&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.ValidationResult"><a class="docstring-binding" href="#MathJSON.ValidationResult"><code>MathJSON.ValidationResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ValidationResult</code></pre><p>Result of validating a MathJSON expression.</p><p><strong>Fields</strong></p><ul><li><code>valid::Bool</code>: Whether the expression is valid</li><li><code>errors::Vector{String}</code>: List of validation error messages (empty if valid)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">result = ValidationResult(true, String[])
result.valid  # true
isempty(result.errors)  # true

result = ValidationResult(false, [&quot;Invalid operator: Foo&quot;])
result.valid  # false
result.errors  # [&quot;Invalid operator: Foo&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Metadata"><a class="docs-heading-anchor" href="#Metadata">Metadata</a><a id="Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Metadata" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.metadata"><a class="docstring-binding" href="#MathJSON.metadata"><code>MathJSON.metadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">metadata(expr::AbstractMathJSONExpr)</code></pre><p>Return the metadata dictionary associated with the expression, or <code>nothing</code> if no metadata is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">n = NumberExpr(42; metadata=Dict(&quot;wikidata&quot; =&gt; &quot;Q167&quot;))
metadata(n)  # Dict{String, Any}(&quot;wikidata&quot; =&gt; &quot;Q167&quot;)

s = SymbolExpr(&quot;x&quot;)
metadata(s)  # nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.with_metadata"><a class="docstring-binding" href="#MathJSON.with_metadata"><code>MathJSON.with_metadata</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">with_metadata(expr, key::String, value) -&gt; AbstractMathJSONExpr</code></pre><p>Return a new expression with the given key-value pair added to its metadata. If the expression already has metadata, the new key-value is merged in. The original expression is not modified.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">n = NumberExpr(42)
n2 = with_metadata(n, &quot;wikidata&quot;, &quot;Q167&quot;)
metadata(n2)  # Dict{String, Any}(&quot;wikidata&quot; =&gt; &quot;Q167&quot;)
metadata(n)   # nothing (original unchanged)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section><section><div><pre><code class="language-julia hljs">with_metadata(expr, metadata::Dict{String, Any}) -&gt; AbstractMathJSONExpr</code></pre><p>Return a new expression with the given metadata dictionary, replacing any existing metadata. The original expression is not modified.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">n = NumberExpr(42; metadata=Dict(&quot;old&quot; =&gt; &quot;value&quot;))
n2 = with_metadata(n, Dict{String, Any}(&quot;new&quot; =&gt; &quot;value&quot;))
metadata(n2)  # Dict{String, Any}(&quot;new&quot; =&gt; &quot;value&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.OperatorCategory"><a class="docstring-binding" href="#MathJSON.OperatorCategory"><code>MathJSON.OperatorCategory</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">OperatorCategory</code></pre><p>Module containing the operator category enum. Use scoped access to avoid namespace pollution.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">cat = OperatorCategory.ARITHMETIC
cat isa OperatorCategory.T  # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.OPERATORS"><a class="docstring-binding" href="#MathJSON.OPERATORS"><code>MathJSON.OPERATORS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">OPERATORS::Dict{Symbol, OperatorCategory.T}</code></pre><p>Dictionary mapping MathJSON operator symbols to their categories. Loaded from data/operators.json at module initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.JULIA_FUNCTIONS"><a class="docstring-binding" href="#MathJSON.JULIA_FUNCTIONS"><code>MathJSON.JULIA_FUNCTIONS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">JULIA_FUNCTIONS::Dict{Symbol, Function}</code></pre><p>Dictionary mapping MathJSON operators to Julia functions. Used for converting MathJSON expressions to executable Julia code and for Symbolics.jl integration. Loaded from data/julia_functions.json at module initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.get_category"><a class="docstring-binding" href="#MathJSON.get_category"><code>MathJSON.get_category</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_category(op::Symbol) -&gt; OperatorCategory.T</code></pre><p>Return the category for a MathJSON operator, or <code>UNKNOWN</code> if the operator is not recognized.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">get_category(:Add)      # OperatorCategory.ARITHMETIC
get_category(:Sin)      # OperatorCategory.TRIGONOMETRIC
get_category(:Custom)   # OperatorCategory.UNKNOWN</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.get_julia_function"><a class="docstring-binding" href="#MathJSON.get_julia_function"><code>MathJSON.get_julia_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_julia_function(op::Symbol) -&gt; Union{Function, Nothing}</code></pre><p>Return the Julia function corresponding to a MathJSON operator, or <code>nothing</code> if no mapping exists.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">get_julia_function(:Add)     # +
get_julia_function(:Sin)     # sin
get_julia_function(:Custom)  # nothing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.is_known_operator"><a class="docstring-binding" href="#MathJSON.is_known_operator"><code>MathJSON.is_known_operator</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_known_operator(op::Symbol) -&gt; Bool</code></pre><p>Return <code>true</code> if the operator is a known MathJSON standard library operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">is_known_operator(:Add)     # true
is_known_operator(:Sin)     # true
is_known_operator(:Custom)  # false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Symbolics.jl-Integration"><a class="docs-heading-anchor" href="#Symbolics.jl-Integration">Symbolics.jl Integration</a><a id="Symbolics.jl-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolics.jl-Integration" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.to_symbolics"><a class="docstring-binding" href="#MathJSON.to_symbolics"><code>MathJSON.to_symbolics</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_symbolics(expr::AbstractMathJSONExpr)</code></pre><p>Convert a MathJSON expression to a Symbolics.jl expression.</p><p>This function requires the Symbolics.jl package to be loaded. Load it with <code>using Symbolics</code> before calling this function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Symbolics
expr = parse(MathJSONFormat, &quot;[&quot;Add&quot;, &quot;x&quot;, 1]&quot;)
symbolic = to_symbolics(expr)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.from_symbolics"><a class="docstring-binding" href="#MathJSON.from_symbolics"><code>MathJSON.from_symbolics</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">from_symbolics(expr)</code></pre><p>Convert a Symbolics.jl expression to a MathJSON expression.</p><p>This function requires the Symbolics.jl package to be loaded. Load it with <code>using Symbolics</code> before calling this function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Symbolics
@variables x
mathjson = from_symbolics(x + 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><h2 id="Errors"><a class="docs-heading-anchor" href="#Errors">Errors</a><a id="Errors-1"></a><a class="docs-heading-anchor-permalink" href="#Errors" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MathJSON.MathJSONParseError"><a class="docstring-binding" href="#MathJSON.MathJSONParseError"><code>MathJSON.MathJSONParseError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MathJSONParseError &lt;: Exception</code></pre><p>Exception thrown when parsing invalid MathJSON input.</p><p><strong>Fields</strong></p><ul><li><code>message::String</code>: Description of the parse error</li><li><code>position::Union{Nothing, Int}</code>: Optional position in the input where error occurred</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">throw(MathJSONParseError(&quot;Unexpected token&quot;, 42))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MathJSON.UnsupportedConversionError"><a class="docstring-binding" href="#MathJSON.UnsupportedConversionError"><code>MathJSON.UnsupportedConversionError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnsupportedConversionError &lt;: Exception</code></pre><p>Exception thrown when attempting to convert an unsupported MathJSON expression to Symbolics.jl or vice versa.</p><p><strong>Fields</strong></p><ul><li><code>message::String</code>: Description of the conversion error</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">throw(UnsupportedConversionError(&quot;Unknown operator: CustomOp&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/s-celles/MathJSON.jl">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operator Registry</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 19 February 2026 12:31">Thursday 19 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
